package pds

import (
	"fmt"
	"log"

	api "github.com/abhisek/supply-chain-gateway/services/gen"
	"github.com/abhisek/supply-chain-gateway/services/pkg/common/db/models"
)

type vulnerabilityAffected struct {
	Versions []string
}

// We may have different vulnerability sources and data provider.
// The vulnerability data has meaning based on vuln.SchemaType and vuln.SchemaVersion
// We need adapters/wrappers that can be plugged in to make sense of vuln.Data
// and provide an uniform interface to the rest of the system
type VulnerabilitySchemaWrapper interface {
	References() []*api.VulnerabilityReference
	CVE() string
	CWEs() []string

	Affects() []*vulnerabilityAffected

	// Return on of CRITICAL, HIGH, MEDIUM, LOW
	FriendlySeverity() string
	FriendlySeverityCode() api.VulnerabilitySeverity

	// Standard form
	Severity() []*api.VulnerabilityScore
}

// Provide a way for different schema wrappers to register themselves
type vulnerabilitySchemaWrapperRegistration struct {
	CanHandle func(t, v string) bool
	Handle    func(models.Vulnerability) (VulnerabilitySchemaWrapper, error)
}

var availableVulnerabilitySchemaWrappers []vulnerabilitySchemaWrapperRegistration

func registerVulnerabilitySchemaWrapper(r vulnerabilitySchemaWrapperRegistration) {
	availableVulnerabilitySchemaWrappers = append(availableVulnerabilitySchemaWrappers, r)
}

func wrapVuln(m models.Vulnerability) (VulnerabilitySchemaWrapper, error) {
	for _, w := range availableVulnerabilitySchemaWrappers {
		if w.CanHandle(m.SchemaType, m.SchemaVersion) {
			h, err := w.Handle(m)
			if err != nil {
				log.Printf("Handler failed to setup for %v with error %v", w, err)
				continue
			}

			return h, nil
		}
	}

	return nil, fmt.Errorf("no wrappers found for %s:%s", m.SchemaType, m.SchemaVersion)
}
